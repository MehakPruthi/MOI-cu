---
title: "edu"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(data.table)
library(rgeos)
library(rgdal)
library(sp)
library(foreach)
library(doParallel)
library(tictoc)
library(gridExtra)
source("helpers.R")
```
- *TODO* get rid of Quebec zones
- *TODO* school density should be included to help prediction, 
- *TODO* test closest school hypothesis
- *TODO* check where the decimals stem from.
- *TODO* High level finding of proportion of students going to nearest school by board, region. 
- *TODO* Utilization vs travel time

## Import relavent files
```{r Import files, include=FALSE}
# TRESO 
treso_shp <- readOGR(dsn = "input", layer = "TRESO_Zones_SocioData_Gatineau_LCC")
treso_tb <- readRDS("output/treso_tb.rds")

# Definition files
school_board_def <- read_csv("input/school_board_types.csv")
treso_zone_def <- read_csv("input/treso_zone_system.csv")

# Student travel data
student_travel_90 <- readRDS("output/student_travel_0.9.rds")
student_travel_80 <- readRDS("output/student_travel_0.8.rds")
student_travel_70 <- readRDS("output/student_travel_0.7.rds")
student_travel_60 <- readRDS("output/student_travel_0.6.rds")
student_travel_50 <- readRDS("output/student_travel_0.5.rds")

# School related data
school_sfis_2017 <- readRDS("output/school_sfis_2017.rds") %>%
  rename(year = year.x)
```

## Summary of School Utilization

- Plot a chart showing the average utilization per DSB and board type.

```{r school utilization}
school_sfis_2017 %>%
  left_join(school_board_def, by = c('dsb.index'='dsb')) %>%
  group_by(dsb.index, panel) %>%
  summarise(
    utilization.total = mean(utilization.total),
    board_type_name = first(board_type_name)
  ) %>%
  ggplot(aes(x = dsb.index, y = utilization.total, fill = board_type_name)) +
  geom_col(position = 'dodge') +
  labs(x = 'DSB', y = 'Average Utilization', fill = 'Board Type') +
  theme_minimal()

```


## Find Closest School for each Student

- Get the coordinates for schools and students
- Get the projection from the TRESO shapefile
- Transform the coordinates to use the same projection system as TRESO shapefile

```{r plotting shapefiles, echo = FALSE}
student_xy <- create_student_xy(student_travel_90)
school_xy <- create_school_xy(student_travel_90)

# Convert the SpatialDataframe to normal Dataframe for ggplot()
treso_shp_df <- fortify(treso_shp) %>%
  rename(
    x = long,
    y = lat
  )

school_xy_df <- data.frame(school_xy) %>%
  rename(
    x = long,
    y = lat
  )

student_xy_df <- data.frame(student_xy) %>%
  rename(
    x = long,
    y = lat
  )

ggplot() +
  geom_polygon(data = treso_shp_df, mapping = aes(x = x, y = y, group = group),
               fill = 'grey40', color = 'grey90', alpha = 1, size = 0.1) +
  geom_point(data = student_xy_df, mapping = aes(x = x, y = y), color = "red", alpha = 0.1, size = 0.01) +
  geom_point(data = school_xy_df, mapping = aes(x = x, y = y), color = "blue", alpha = 0.1, size = 0.01, shape = 2) +
  labs(x = "", y = "", title = "Students and schools in Ontario") +
  theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(),
        axis.ticks.x = element_blank(), axis.text.x = element_blank(),
        plot.title = element_text(lineheight = 0.8, face = "bold", vjust = 1)) +
  coord_equal(ratio = 1)

# ggsave(treso_plot, file = "output/treso_with_points.png", width = 10, height = 10)

# Clean up the global environments
rm(school_xy_df, treso_shp_df, student_xy_df)
```

## Spatial Gymnastics

- Loop and do the following for all catchment distance available
- Using `over()` to determine the treso zone number for each student/school point
- Using `gbuffer()` to determine the treso zones that catchment distance touches for each school
- Setting up the multi-core to do `foreach()` loop is worth it once you are doing more than 100 fields
  - 100 fields: 29s compared to 19s
  - 1000 fields: 252s compared to 116s
- Combine the the datalist of buffered TRESO zones with the tibble containing socio-economic data
- Combine with the historical ADE and utilization data by school

```{r spatial gymnastics, eval = TRUE, echo = FALSE}
percentile_dist = c('90', '80', '70', '60', '50')

for (dist in percentile_dist) {
  # Loop through the different catchment areas by retriving the
  # proper variable.
  student_travel <- get(paste0("student_travel_",dist))
  
  # Spatial transformation to XY
  student_xy <- create_student_xy(student_travel)
  school_xy <- create_school_xy(student_travel)
  
  # Create the overlays to get the TRESO zone each XY coordinate falls on
  student_overlay <- create_overlay(student_xy, treso_shp, "student")
  saveRDS(student_overlay, paste0("output/student_overlay_", dist, ".rds"))
  school_overlay <- create_overlay(school_xy, treso_shp, "school")
  
  # Join the POR and POS together for distance matrix
  observed_por_pos <- left_join(student_overlay, school_overlay, by = "school.name") %>%
    saveRDS(paste0("output/observed_por_pos_", dist, ".rds"))
  
  # Save the zones in each school's catchment area
  buffered_df <- buffer_zones(school_xy, treso_shp)
  saveRDS(buffered_df, paste0("output/school_catchment_treso_zones_", dist, ".rds"))
  
  # Combine the school's buffered TRESO zones with socio-economic info and group_by school name
  school_tb <- summarize_buffered_zones(buffered_df, treso_tb, school_sfis_2017, school_board_def, treso_zone_def) %>%
    saveRDS(paste0("output/school_tb_", dist, ".rds"))
}
```

- Test that `gBuffer()` is returning intended results.

```{r test buffer, eval = FALSE, echo = FALSE}
# Select a specific buffer
school_of_interest <- "A A Wright PS"
student_travel <- get("student_travel_90")
student_xy <- create_student_xy(student_travel)
school_xy <- create_school_xy(student_travel)
buffered_points <- gBuffer(school_xy, width = school_xy@data$catchment.dist * 1000, byid = TRUE)
buffer <- buffered_points[buffered_points@data$school.name == school_of_interest, ]

# Get all TRESO zones that touches the buffer with over(), gIntersect() could be another solution
treso_overlay <- over(treso_shp, buffer, returnList = FALSE) %>%
  cbind(treso.id = treso_shp@data$Treso_ID,
        households = treso_shp@data$TotHH,
        persons = treso_shp@data$TotPers) %>%
  as.tibble() %>%
  select(school.name, sfis, dsb.index, catchment.dist, treso.id, households, persons) %>%
  drop_na()

# Select the TRESO zones of interest
treso_zones_interest <- treso_shp[is.element(treso_shp@data$Treso_ID, treso_overlay$treso.id), ] %>%
  fortify() %>%
  rename(
    x = long, 
    y = lat
  )

interst_zones <- treso_overlay

# Convert buffer into df
buffer_df <- fortify(buffer) %>%
  rename(
    x = long, 
    y = lat
  )

school_xy_df <- data.frame(school_xy) %>%
  rename(
    x = long,
    y = lat
  )

# Plot the school, buffer and the selected TRESO zones
ggplot() +
  geom_polygon(data = treso_zones_interest, mapping = aes(x = x, y = y, group = group), 
               fill = 'grey40', color = 'grey90', alpha = 1, size = 0.1) +
  geom_polygon(data = buffer_df, mapping = aes(x = x, y = y, group = group),
               fill = 'red', color = 'red', alpha = 0.5) +
  geom_point(data = filter(school_xy_df, school.name == school_of_interest), mapping = aes(x = x, y = y), 
               fill = "blue", alpha = 0.5, size = 10) +
  labs(x = "", y = "", title = "Test Buffer") +
  theme(plot.title = element_text(lineheight = 0.8, face = "bold", vjust = 1)) +
  coord_equal(ratio = 1)

# Clean up global environment variables
rm(school_of_interest, buffer, treso_overlay, treso_zones_interest, buffer_df, school_xy_df)
```

## Test closest school theory

- From `student_travel_90`, obtain the travel distance to create a buffer for each student
- Build a buffer with the travel distance and capture any school within that buffer
- Make sure the school is from `school_sfis`
- Calculate the distance to all the schools within its travel distance buffer
  - if no school exist then this student is travelling to closest (labelled 1)
  - if there are schools within this buffer, then the label a value equal in rank (2 - n)

```{r closest school}
student_xy_90 <- student_travel_90 %>%
  select(sfis, bsid, school.name, school.lat, school.long, dsb.index, panel, enrolment, student.postal.code, student.lat, student.long,
         dist) %>%
  create_student_xy()

student_buffered <- gBuffer(student_xy_90, width = (student_xy_90@data$euclidean.dist * 1000 + 25), byid = TRUE)

tic('Multi-Core Buffering')
# Start multi-core clustering for performance
cores = parallel::detectCores()
cl <- parallel::makeCluster(cores[1] - 2)
registerDoParallel(cl)

# foreach() loop to find the TRESO zones touching the school buffers
datalist <- list()
datalist <- foreach(i = 1:nrow(student_buffered@data), .packages=c('sp', 'tidyverse', 'rgeos')) %dopar% {
#datalist <- foreach(i = 1:10, .packages=c('sp', 'tidyverse', 'rgeos')) %dopar% {
  # Select the buffer
  buffer <- student_buffered[student_buffered@data$id == i, ]
  
  # Get all schools that touches the buffer with over(), gIntersect() could be another solution
  school_overlay <- over(school_xy, buffer, returnList = FALSE) %>%
      cbind(overlay.school.name = school_xy@data$school.name,
            overlay.dsb.index = school_xy@data$dsb.index,
            overlay.sfis = school_xy@data$sfis,
            overlay.panel = school_xy@data$panel,
            overlay.coords = school_xy@coords) %>%
      as.tibble() %>%
      drop_na()
  
  # Save each tibble in a list of tibbles
  datalist[[i]] <- school_overlay
  
  # Check the length of datalist, if it is over 4000 write to file
  if(length(datalist) >= 4000) {
    school_overlay_df <- rbindlist(datalist) %>%
      saveRDS(paste0("output/closest_school_", i, ".rds"))
    rm(datalist, school_overlay_df)
  }
}

stopCluster(cl)
toc()

# Write the datalist to csv
school_overlay_df <- rbindlist(datalist) 
saveRDS(school_overlay_df, 'output/closest_school.rds')
  
# TODO check that the home school should be part of the buffered school set. It is not the case at the moment.
TESTID = 5
# Convert buffer into df
buffer_df <- fortify(student_buffered[student_buffered@data$id == TESTID, ]) %>%
  rename(
    x = long, 
    y = lat
  )

student_interest_df <- student_xy[is.element(student_xy@data$id, TESTID), ] %>%
  data.frame() %>%
  rename(
    x = long,
    y = lat
  )

# Select the schools of interest that exist in the 
school_interest_df <- school_xy[is.element(school_xy@data$sfis, school_overlay_df$overlay.sfis), ] %>%
  data.frame() %>%
  rename(
    x = long, 
    y = lat
  )

ggplot() +
  geom_point(data = filter(student_xy_df, id == TESTID), mapping = aes(x = x, y = y), 
               color = 'blue', fill = "blue", alpha = 1, size = 3) +
  geom_point(data = school_interest_df, mapping = aes(x = x, y = y), 
               color = 'green', fill = "green", alpha = 1, size = 3) +
  geom_text(data = school_interest_df, aes(x = x, y = y, label = school.name), size = 2) +
  geom_polygon(data = buffer_df, mapping = aes(x = x, y = y, group = group),
               fill = 'red', color = 'red', alpha = 0.01) +
  labs(x = "", y = "", title = "Test Buffer") +
  theme(plot.title = element_text(lineheight = 0.8, face = "bold", vjust = 1)) +
  coord_equal(ratio = 1)

```

## Straight Line TLFD plots {.tabset .tabset-fade}

- Convert this to use the TRESO distance once we obtain the skims. (*need to obtain*)
- Using `uncount()` to convert the enrollment number to individual entries in the tibble

```{r read in the student overlay RDS, echo = FALSE}
# Create overlays for the 90th catchment distance
student_overlay_90 <- readRDS("output/student_overlay_90.rds")
student_overlay_80 <- readRDS("output/student_overlay_80.rds")
student_overlay_70 <- readRDS("output/student_overlay_70.rds")
student_overlay_60 <- readRDS("output/student_overlay_60.rds")
student_overlay_50 <- readRDS("output/student_overlay_50.rds")
```

### 90th Percentile plots
```{r tlfd plots for 90th percentile, fig.width = 10, fig.height = 28, echo = FALSE}
student_tlfd_90 <- student_travel_90 %>% 
  select(dsb.index, dist, enrolment, panel, student.postal.code) %>%
  left_join(select(school_board_def, dsb, board_type_name), by = c('dsb.index' = 'dsb')) %>%
  left_join(select(student_overlay_90, student.postal.code, treso.id.por), by = "student.postal.code") %>%
  rename(treso.id = treso.id.por) %>%
  left_join(select(treso_zone_def, treso_id, area, mof_region), by = c('treso.id' = 'treso_id')) %>%
  # MOF Region of NA are Quebec Zones
  filter(mof_region != "NA") %>%
  # expand the rows based on enrollment number
  uncount(enrolment)

plot_straight_line_tlfd(student_tlfd_90)
```

### 80th Percentile plots
```{r tlfd plots for 80th percentile, fig.width = 10, fig.height = 28, echo = FALSE}
student_tlfd_80 <- student_travel_80 %>% 
  select(dsb.index, dist, enrolment, panel, student.postal.code) %>%
  left_join(select(school_board_def, dsb, board_type_name), by = c('dsb.index' = 'dsb')) %>%
  left_join(select(student_overlay_80, student.postal.code, treso.id.por), by = "student.postal.code") %>%
  rename(treso.id = treso.id.por) %>%
  left_join(select(treso_zone_def, treso_id, area, mof_region), by = c('treso.id' = 'treso_id')) %>%
  # MOF Region of NA are Quebec Zones
  filter(mof_region != "NA") %>%
  # expand the rows based on enrollment number
  uncount(enrolment)

plot_straight_line_tlfd(student_tlfd_80)
```

### 70th Percentile plots
```{r tlfd plots for 70th percentile, fig.width = 10, fig.height = 28, echo = FALSE}
student_tlfd_70 <- student_travel_70 %>% 
  select(dsb.index, dist, enrolment, panel, student.postal.code) %>%
  left_join(select(school_board_def, dsb, board_type_name), by = c('dsb.index' = 'dsb')) %>%
  left_join(select(student_overlay_70, student.postal.code, treso.id.por), by = "student.postal.code") %>%
  rename(treso.id = treso.id.por) %>%
  left_join(select(treso_zone_def, treso_id, area, mof_region), by = c('treso.id' = 'treso_id')) %>%
  # MOF Region of NA are Quebec Zones
  filter(mof_region != "NA") %>%
  # expand the rows based on enrollment number
  uncount(enrolment)

plot_straight_line_tlfd(student_tlfd_70)
```

### 50th Percentile plots
```{r tlfd plots for 50th percentile, fig.width = 10, fig.height = 28, echo = FALSE}
student_tlfd_50 <- student_travel_50 %>% 
  select(dsb.index, dist, enrolment, panel, student.postal.code) %>%
  left_join(select(school_board_def, dsb, board_type_name), by = c('dsb.index' = 'dsb')) %>%
  left_join(select(student_overlay_50, student.postal.code, treso.id.por), by = "student.postal.code") %>%
  rename(treso.id = treso.id.por) %>%
  left_join(select(treso_zone_def, treso_id, area, mof_region), by = c('treso.id' = 'treso_id')) %>%
  # MOF Region of NA are Quebec Zones
  filter(mof_region != "NA") %>%
  # expand the rows based on enrollment number
  uncount(enrolment)


plot_straight_line_tlfd(student_tlfd_50)
```

## Explore Linear Regressions

- Segment the schools by board (at least)
- Build linear regression 
- Explore other segmentations

```{r linear regression, eval = FALSE, echo = FALSE}

# Choose the catchment area to explore
school_tb <- readRDS("output/school_tb_80.rds")

# Filter the school database down
school_tb_filtered <- filter(school_tb, ade > 0, panel == "Secondary", board.type.name == "English Public", 
                             mof.region == "GTA")

# Display schools that has captured a large area and their 2011 ADE
school_tb_filtered %>%
  arrange(desc(n_pop_sum)) %>%
  select(school.name.x, n_pop_sum, ade)

# Build linear regression data base with various transformed x, y variables
# Consider standardizing the data here.
linreg <- school_tb_filtered %>%
  select(ade, starts_with("n_"), starts_with("occu_"), starts_with("deg_"), attend_school_sum, mean.income, mean.age) %>%
  mutate_all(
    funs(ln = log1p(.), sqrt = sqrt(.), sq = .^2)
  ) %>%
  mutate(dummy_large_pop = ifelse(n_pop_sum >= 10e+4, 1, 0)) %>%
  bind_cols(select(school_tb_filtered, sfis, school.name.x))

# TODO: check why ADE at this point is decimals
linreg %>%
  select(ade, school.name.x, sfis) %>%
  filter(ade < 100)

# Exploring the data relationships
ggplot(linreg, aes(y = ade, x = n_pop_sum)) +
  geom_point(alpha = 0.5, color = "#F8766D")
  #geom_smooth(method = "lm", se = FALSE)

# Fully segment the data
linreg_small <- linreg %>%
  filter(n_pop_sum < 10e+4)

linreg_large <- linreg %>%
  filter(n_pop_sum >= 10e+4)

# Build models
mod.small <- lm(ade ~ n_sec_pop_sum_sqrt + n_pt_sum_sqrt + n_two_adult_one_child_sum, data = linreg_small)
summary(mod.small)
plot(mod.small)
mod.large <- lm(ade ~ n_pop_sum_sqrt + n_pt_sum_sqrt + n_one_adult_twoplus_child_sum +
                  n_zero_adult_sum, data = linreg_large)
summary(mod.large)

mod.partial <- lm(ade ~ n_sec_pop_sum_sqrt + n_pop_sum_sqrt + n_pt_sum_sqrt + n_one_adult_twoplus_child_sum +
                  n_zero_adult_sum + dummy_large_pop, data = linreg)
summary(mod.partial)
# mod.base <- lm(ade_2011 ~ n_sec_pop_sum_sqrt, data = linreg)
# mod.expand <- lm(ade_2011 ~ n_sec_pop_sum_sqrt + n_ele_pop_sum_sqrt, data = linreg)
# anova(mod.base, mod.expand)
# 
# summary(mod.base)
# summary(mod.expand)
# plot(mod.expand)
```


